{"version":3,"file":"index.js","sources":["../src/Box.ts","../src/QuadTree.ts","../src/Circle.ts","../src/Point.ts"],"sourcesContent":["/**\n * Box class.\n * @class Box\n */\nimport {Point} from \"./Point\";\nimport {Shape, UserCustomData} from \"./types\";\n\nexport class Box implements Shape{\n    readonly x: number;\n    readonly y: number;\n    readonly w: number;\n    readonly h: number;\n    readonly data: UserCustomData;\n\n    /**\n     * Box constructor;\n     * @constructs Box\n     * @param {number} x - X coordinate of the box.\n     * @param {number} y - Y coordinate of the box.\n     * @param {number} w - Width of the box.\n     * @param {number} h - Height of the box.\n     * @param {*} [data] - Data to store along the box.\n     */\n    constructor(x: number, y: number, w: number, h: number, data?: UserCustomData) {\n        this.x = x;\n        this.y = y;\n        this.w = w;\n        this.h = h;\n        this.data = data;\n    }\n\n    /**\n     * Check if a point is contained in the box.\n     * @param {Point|Object} point - The point to test if it is contained in the box.\n     * @returns {boolean} - True if the point is contained in the box, otherwise false.\n     */\n    contains(point: Point): boolean {\n        return point.x >= this.x &&\n            point.x <= this.x + this.w &&\n            point.y >= this.y &&\n            point.y <= this.y + this.h;\n    }\n\n    /**\n     * Check if a box intersects with this box.\n     * @param {Box|Object} range - The box to test the intersection with.\n     * @returns {boolean} - True if it intersects, otherwise false.\n     */\n    intersects(range: Box): boolean {\n        return !(range.x > this.x + this.w\n            || range.x + range.w < this.x\n            || range.y > this.y + this.h\n            || range.y + range.h < this.y);\n    }\n\n}\n","import {Box} from './Box';\nimport {Point} from './Point';\nimport {QuadTreeConfig, QuadTreeConfigComplete, Tree, Shape} from \"./types\";\n\nconst defaultConfig: QuadTreeConfigComplete = {\n    capacity: 4,\n    removeEmptyNodes: false,\n    maximumDepth: -1,\n    arePointsEqual: (point1: Point, point2: Point) => point1.x === point2.x && point1.y === point2.y\n};\n\n/**\n * QuadTree class.\n * @class QuadTree\n */\nexport class QuadTree {\n    private readonly container: Box;\n    private isDivided: boolean;\n    private points: Point[];\n    private readonly config: QuadTreeConfigComplete;\n    private ne!: QuadTree;\n    private nw!: QuadTree;\n    private se!: QuadTree;\n    private sw!: QuadTree;\n\n    /**\n     * Create a new QuadTree\n     * @constructor\n     * @param {Box} container - The box on which the QuadTree will operate.\n     * @param {Object} [config] - The configuration of the quadtree.\n     * @param {number} [config.capacity] - The maximum amount of points per node.\n     * @param {boolean} [config.removeEmptyNodes] - Specify if the quadtree has to remove subnodes if they are empty.\n     * @param {number} [config.maximumDepth] - Specify the maximum depth of the tree.\n     * @param {function} [config.arePointsEqual] - Specify a custom method to compare point for removal.\n     * @param {(Object[]|Point[])} [points] - An array of initial points to insert in the QuadTree.\n     * @param {number} points[].x - X coordinate of the point.\n     * @param {number} points[].y - Y coordinate of the point.\n     */\n    constructor(container: Box, config?: QuadTreeConfig, points: Point[] = []) {\n        this.container = container;\n        this.config = Object.assign({}, defaultConfig, config);\n\n        this.isDivided = false;\n        this.points = [];\n\n        for (const point of points) {\n            this.insertRecursive(point);\n        }\n    }\n\n    /**\n     * Return a tree representation of the QuadTree\n     * @returns {{se: *, sw: *, ne: *, nw: *}|Number} - A tree representation of the QuadTree\n     */\n    getTree(): Tree {\n        let tree;\n\n        if (this.isDivided) {\n            tree = {\n                ne: this.ne.getTree(),\n                nw: this.nw.getTree(),\n                se: this.se.getTree(),\n                sw: this.sw.getTree()\n            };\n\n        } else {\n            tree = this.getNodePointAmount();\n        }\n\n        return tree;\n    }\n\n    /**\n     * Get all the points in the QuadTree\n     * @returns {(Object[]|Point[])} - An array containing all the points.\n     */\n    getAllPoints(): Point[] {\n        const pointsList: Point[] = [];\n        this.getAllPointsRecursive(pointsList);\n        return pointsList;\n    }\n\n    /**\n     * Get all the points in the QuadTree\n     * @param {(Object[]|Point[])} pointsList\n     * @private\n     */\n    private getAllPointsRecursive(pointsList: Point[]): void {\n        if (!this.isDivided) {\n            Array.prototype.push.apply(pointsList, this.points.slice());\n            return;\n        }\n\n        this.ne.getAllPointsRecursive(pointsList);\n        this.nw.getAllPointsRecursive(pointsList);\n        this.se.getAllPointsRecursive(pointsList);\n        this.sw.getAllPointsRecursive(pointsList);\n    }\n\n    /**\n     * Return the amount of points in this node.\n     * @returns {number} - The amount of points in this node.\n     * @private\n     */\n    private getNodePointAmount(): number {\n        return this.points.length;\n    }\n\n    /**\n     * Divide this node into 4 sub-nodes\n     * @private\n     */\n    private divide(): void {\n        const childMaximumDepth = this.config.maximumDepth === -1 ? -1 : this.config.maximumDepth - 1;\n        const childConfig: QuadTreeConfig = Object.assign({}, this.config, {maximumDepth: childMaximumDepth});\n\n        this.isDivided = true;\n\n        const x = this.container.x;\n        const y = this.container.y;\n        const w = this.container.w / 2;\n        const h = this.container.h / 2;\n\n        // Creation of the sub-nodes, and insertion of the current point\n        this.ne = new QuadTree(new Box(x + w, y, w, h), childConfig);\n        this.nw = new QuadTree(new Box(x, y, w, h), childConfig);\n        this.se = new QuadTree(new Box(x + w, y + h, w, h), childConfig);\n        this.sw = new QuadTree(new Box(x, y + h, w, h), childConfig);\n\n        this.insert(this.points.slice());\n\n        // We empty this node points\n        this.points.length = 0;\n        this.points = [];\n    }\n\n    /**\n     * Remove a point in the QuadTree\n     * @param {(Point|Object|Point[]|Object[])} pointOrArray - A point or an array of points to remove\n     * @param {number} pointOrArray.x - X coordinate of the point\n     * @param {number} pointOrArray.y - Y coordinate of the point\n     */\n    remove(pointOrArray: Point | Point[]): void {\n        if (Array.isArray(pointOrArray)) {\n            for (const point of pointOrArray) {\n                this.removeRecursive(point);\n            }\n        } else {\n            this.removeRecursive(pointOrArray);\n        }\n    }\n\n    /**\n     * Remove a point in the QuadTree\n     * @param {(Point|Object)} point - A point to remove\n     * @param {number} point.x - X coordinate of the point\n     * @param {number} point.y - Y coordinate of the point\n     * @private\n     */\n    private removeRecursive(point: Point): void {\n        if (!this.container.contains(point)) {\n            return;\n        }\n\n        if (!this.isDivided) {\n            const len = this.points.length;\n            for (let i = len - 1; i >= 0; i--) {\n                if (this.config.arePointsEqual(point, this.points[i])) {\n                    this.points.splice(i, 1);\n                }\n            }\n\n            return;\n        }\n\n        this.ne.removeRecursive(point);\n        this.nw.removeRecursive(point);\n        this.se.removeRecursive(point);\n        this.sw.removeRecursive(point);\n\n        if (this.config.removeEmptyNodes) {\n            if (this.ne.getNodePointAmount() === 0 && !this.ne.isDivided &&\n                this.nw.getNodePointAmount() === 0 && !this.nw.isDivided &&\n                this.se.getNodePointAmount() === 0 && !this.se.isDivided &&\n                this.sw.getNodePointAmount() === 0 && !this.sw.isDivided) {\n\n                this.isDivided = false;\n\n                delete this.ne;\n                delete this.nw;\n                delete this.se;\n                delete this.sw;\n            }\n        }\n    }\n\n    /**\n     * Insert a point in the QuadTree\n     * @param {(Point|Object|Point[]|Object[])} pointOrArray - A point or an array of points to insert\n     * @param {number} pointOrArray.x - X coordinate of the point\n     * @param {number} pointOrArray.y - Y coordinate of the point\n     * @returns {boolean} true if the point or all the point has been inserted, false otherwise\n     */\n    insert(pointOrArray: Point | Point[]): boolean {\n        if (Array.isArray(pointOrArray)) {\n            let returnValue = true;\n            for (const point of pointOrArray) {\n                returnValue = returnValue && this.insertRecursive(point);\n            }\n            return returnValue;\n        } else {\n            return this.insertRecursive(pointOrArray);\n        }\n    }\n\n    /**\n     * Insert a point in the QuadTree\n     * @param {(Point|Object)} point - A point to insert\n     * @param {number} point.x - X coordinate of the point\n     * @param {number} point.y - Y coordinate of the point\n     * @returns {boolean}\n     * @private\n     */\n    private insertRecursive(point: Point): boolean {\n        if (!this.container.contains(point)) {\n            return false;\n        }\n        if (!this.isDivided) {\n            if (this.getNodePointAmount() < this.config.capacity || this.config.maximumDepth === 0) {\n                this.points.push(point);\n                return true;\n            } else if (this.config.maximumDepth === -1 || this.config.maximumDepth > 0) {\n                this.divide();\n            }\n        }\n\n        if (this.isDivided) {\n            return this.ne.insertRecursive(point) \n                || this.nw.insertRecursive(point) \n                || this.se.insertRecursive(point) \n                || this.sw.insertRecursive(point);\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Query all the point within a range\n     * @param {Shape} range - The range to test\n     * @returns {(Point[]|Object[])} - The points within the range\n     */\n    query(range: Shape): Point[] {\n        const pointsFound: Point[] = [];\n        this.queryRecursive(range, pointsFound);\n        return pointsFound;\n    }\n\n    /**\n     * @param {Shape} range\n     * @param {(Point[]|Object[])} pointsFound\n     * @returns {(Point[]|Object[])}\n     * @private\n     */\n    private queryRecursive(range: Shape, pointsFound: Point[]): void {\n        if (range.intersects(this.container)) {\n            if (this.isDivided) {\n                this.ne.queryRecursive(range, pointsFound);\n                this.nw.queryRecursive(range, pointsFound);\n                this.se.queryRecursive(range, pointsFound);\n                this.sw.queryRecursive(range, pointsFound);\n            } else {\n                const p = this.points.filter((point) => range.contains(point));\n\n                Array.prototype.push.apply(pointsFound, p);\n            }\n        }\n    }\n\n    /**\n     * Clear the QuadTree\n     */\n    clear(): void {\n        this.points = [];\n        this.isDivided = false;\n\n        delete this.ne;\n        delete this.nw;\n        delete this.se;\n        delete this.sw;\n    }\n}\n\n\n","/**\n * Box Circle.\n * @class Circle\n */\nimport {Point} from \"./Point\";\nimport {Box} from \"./Box\";\nimport {Shape, UserCustomData} from \"./types\";\n\nexport class Circle  implements Shape{\n    readonly x: number;\n    readonly y: number;\n    readonly r: number;\n    readonly rPow2: number;\n    readonly data: UserCustomData;\n\n    /**\n     * Circle constructor;\n     * @constructs Circle\n     * @param {number} x - X coordinate of the circle.\n     * @param {number} y - Y coordinate of the circle.\n     * @param {number} r - Radius of the circle.\n     * @param {*} [data] - Data to store along the circle.\n     */\n    constructor(x: number, y: number, r: number, data?: UserCustomData) {\n        this.x = x;\n        this.y = y;\n        this.r = r;\n        this.rPow2 = this.r * this.r; // To avoid square roots\n        this.data = data;\n    }\n\n    private euclideanDistancePow2(point1: Point, point2: Point): number {\n        return Math.pow((point1.x - point2.x), 2) + Math.pow((point1.y - point2.y), 2);\n    }\n\n    /**\n     * Check if a point is contained in the circle.\n     * @param {Point|Object} point - The point to test if it is contained in the circle.\n     * @returns {boolean} - True if the point is contained in the circle, otherwise false.\n     */\n    contains(point: Point): boolean {\n        return this.euclideanDistancePow2(point, this) <= this.rPow2;\n    }\n\n    /**\n     * Check if a box intersects with this circle.\n     * @param {Box|Object} range - The box to test the intersection with.\n     * @returns {boolean} - True if it intersects, otherwise false.\n     */\n    intersects(range: Box): boolean {\n        const dX = this.x - Math.max(range.x, Math.min(this.x, range.x + range.w));\n        const dY = this.y - Math.max(range.y, Math.min(this.y, range.y + range.h));\n        return (dX * dX + dY * dY) <= (this.rPow2);\n    }\n}\n","/**\n * Point class.\n * @class Point\n */\nimport {UserCustomData} from \"./types\";\n\nexport class Point {\n    readonly x: number;\n    readonly y: number;\n    readonly data: UserCustomData;\n\n    /**\n     * Point constructor.\n     * @constructs Point\n     * @param {number} x - X coordinate of the point.\n     * @param {number} y - Y coordinate of the point.\n     * @param {*} [data] - Data to store along the point.\n     */\n    constructor(x: number, y: number, data?: UserCustomData) {\n        this.x = x;\n        this.y = y;\n        this.data = data;\n    }\n\n}"],"names":["Box","[object Object]","x","y","w","h","data","this","point","range","defaultConfig","capacity","removeEmptyNodes","maximumDepth","arePointsEqual","point1","point2","QuadTree","container","config","points","Object","assign","isDivided","insertRecursive","tree","ne","getTree","nw","se","sw","getNodePointAmount","pointsList","getAllPointsRecursive","Array","prototype","push","apply","slice","length","childMaximumDepth","childConfig","insert","pointOrArray","isArray","removeRecursive","contains","i","splice","returnValue","divide","pointsFound","queryRecursive","intersects","p","filter","r","rPow2","Math","pow","euclideanDistancePow2","dX","max","min","dY"],"mappings":"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"}