{"version":3,"file":"index.es.js","sources":["../src/Box.ts","../src/Circle.ts","../src/Point.ts","../src/QuadTree.ts"],"sourcesContent":["/**\n * Box class.\n * @class Box\n */\nimport {Point} from \"./Point\";\nimport {Shape, UserCustomData} from \"./types\";\n\nexport class Box implements Shape{\n    readonly x: number;\n    readonly y: number;\n    readonly w: number;\n    readonly h: number;\n    readonly data: UserCustomData;\n\n    /**\n     * Box constructor;\n     * @constructs Box\n     * @param {number} x - X coordinate of the box.\n     * @param {number} y - Y coordinate of the box.\n     * @param {number} w - Width of the box.\n     * @param {number} h - Height of the box.\n     * @param {*} [data] - Data to store along the box.\n     */\n    constructor(x: number, y: number, w: number, h: number, data?: UserCustomData) {\n        this.x = x;\n        this.y = y;\n        this.w = w;\n        this.h = h;\n        this.data = data;\n    }\n\n    /**\n     * Check if a point is contained in the box.\n     * @param {Point|Object} point - The point to test if it is contained in the box.\n     * @returns {boolean} - True if the point is contained in the box, otherwise false.\n     */\n    contains(point: Point): boolean {\n        return point.x >= this.x &&\n            point.x <= this.x + this.w &&\n            point.y >= this.y &&\n            point.y <= this.y + this.h;\n    }\n\n    /**\n     * Check if a box intersects with this box.\n     * @param {Box|Object} range - The box to test the intersection with.\n     * @returns {boolean} - True if it intersects, otherwise false.\n     */\n    intersects(range: Box): boolean {\n        return !(range.x > this.x + this.w\n            || range.x + range.w < this.x\n            || range.y > this.y + this.h\n            || range.y + range.h < this.y);\n    }\n\n}\n","/**\n * Box Circle.\n * @class Circle\n */\nimport {Point} from \"./Point\";\nimport {Box} from \"./Box\";\nimport {Shape, UserCustomData} from \"./types\";\n\nexport class Circle  implements Shape{\n    readonly x: number;\n    readonly y: number;\n    readonly r: number;\n    readonly rPow2: number;\n    readonly data: UserCustomData;\n\n    /**\n     * Circle constructor;\n     * @constructs Circle\n     * @param {number} x - X coordinate of the circle.\n     * @param {number} y - Y coordinate of the circle.\n     * @param {number} r - Radius of the circle.\n     * @param {*} [data] - Data to store along the circle.\n     */\n    constructor(x: number, y: number, r: number, data?: UserCustomData) {\n        this.x = x;\n        this.y = y;\n        this.r = r;\n        this.rPow2 = this.r * this.r; // To avoid square roots\n        this.data = data;\n    }\n\n    private euclideanDistancePow2(point1: Point, point2: Point): number {\n        return Math.pow((point1.x - point2.x), 2) + Math.pow((point1.y - point2.y), 2);\n    }\n\n    /**\n     * Check if a point is contained in the circle.\n     * @param {Point|Object} point - The point to test if it is contained in the circle.\n     * @returns {boolean} - True if the point is contained in the circle, otherwise false.\n     */\n    contains(point: Point): boolean {\n        return this.euclideanDistancePow2(point, this) <= this.rPow2;\n    }\n\n    /**\n     * Check if a box intersects with this circle.\n     * @param {Box|Object} range - The box to test the intersection with.\n     * @returns {boolean} - True if it intersects, otherwise false.\n     */\n    intersects(range: Box): boolean {\n        const dX = this.x - Math.max(range.x, Math.min(this.x, range.x + range.w));\n        const dY = this.y - Math.max(range.y, Math.min(this.y, range.y + range.h));\n        return (dX * dX + dY * dY) <= (this.rPow2);\n    }\n}\n","/**\n * Point class.\n * @class Point\n */\nimport {UserCustomData} from \"./types\";\n\nexport class Point {\n    readonly x: number;\n    readonly y: number;\n    readonly data: UserCustomData;\n\n    /**\n     * Point constructor.\n     * @constructs Point\n     * @param {number} x - X coordinate of the point.\n     * @param {number} y - Y coordinate of the point.\n     * @param {*} [data] - Data to store along the point.\n     */\n    constructor(x: number, y: number, data?: UserCustomData) {\n        this.x = x;\n        this.y = y;\n        this.data = data;\n    }\n\n}","import {Box} from './Box';\nimport {Point} from './Point';\nimport {QuadTreeConfig, QuadTreeConfigComplete, Tree, Shape} from \"./types\";\n\nconst defaultConfig: QuadTreeConfigComplete = {\n    capacity: 4,\n    removeEmptyNodes: false,\n    maximumDepth: -1,\n    arePointsEqual: (point1: Point, point2: Point) => point1.x === point2.x && point1.y === point2.y\n};\n\n/**\n * QuadTree class.\n * @class QuadTree\n */\nexport class QuadTree {\n    private readonly container: Box;\n    private isDivided: boolean;\n    private points: Point[];\n    private readonly config: QuadTreeConfigComplete;\n    private ne!: QuadTree;\n    private nw!: QuadTree;\n    private se!: QuadTree;\n    private sw!: QuadTree;\n\n    /**\n     * Create a new QuadTree\n     * @constructor\n     * @param {Box} container - The box on which the QuadTree will operate.\n     * @param {Object} [config] - The configuration of the quadtree.\n     * @param {number} [config.capacity] - The maximum amount of points per node.\n     * @param {boolean} [config.removeEmptyNodes] - Specify if the quadtree has to remove subnodes if they are empty.\n     * @param {number} [config.maximumDepth] - Specify the maximum depth of the tree.\n     * @param {function} [config.arePointsEqual] - Specify a custom method to compare point for removal.\n     * @param {(Object[]|Point[])} [points] - An array of initial points to insert in the QuadTree.\n     * @param {number} points[].x - X coordinate of the point.\n     * @param {number} points[].y - Y coordinate of the point.\n     */\n    constructor(container: Box, config?: QuadTreeConfig, points: Point[] = []) {\n        this.container = container;\n        this.config = Object.assign({}, defaultConfig, config);\n\n        this.isDivided = false;\n        this.points = [];\n\n        for (const point of points) {\n            this.insertRecursive(point);\n        }\n    }\n\n    /**\n     * Return a tree representation of the QuadTree\n     * @returns {{se: *, sw: *, ne: *, nw: *}|Number} - A tree representation of the QuadTree\n     */\n    getTree(): Tree {\n        let tree;\n\n        if (this.isDivided) {\n            tree = {\n                ne: this.ne.getTree(),\n                nw: this.nw.getTree(),\n                se: this.se.getTree(),\n                sw: this.sw.getTree()\n            };\n\n        } else {\n            tree = this.getNodePointAmount();\n        }\n\n        return tree;\n    }\n\n    /**\n     * Get all the points in the QuadTree\n     * @returns {(Object[]|Point[])} - An array containing all the points.\n     */\n    getAllPoints(): Point[] {\n        const pointsList: Point[] = [];\n        this.getAllPointsRecursive(pointsList);\n        return pointsList;\n    }\n\n    /**\n     * Get all the points in the QuadTree\n     * @param {(Object[]|Point[])} pointsList\n     * @private\n     */\n    private getAllPointsRecursive(pointsList: Point[]): void {\n        if (!this.isDivided) {\n            Array.prototype.push.apply(pointsList, this.points.slice());\n            return;\n        }\n\n        this.ne.getAllPointsRecursive(pointsList);\n        this.nw.getAllPointsRecursive(pointsList);\n        this.se.getAllPointsRecursive(pointsList);\n        this.sw.getAllPointsRecursive(pointsList);\n    }\n\n    /**\n     * Return the amount of points in this node.\n     * @returns {number} - The amount of points in this node.\n     * @private\n     */\n    private getNodePointAmount(): number {\n        return this.points.length;\n    }\n\n    /**\n     * Divide this node into 4 sub-nodes\n     * @private\n     */\n    private divide(): void {\n        const childMaximumDepth = this.config.maximumDepth === -1 ? -1 : this.config.maximumDepth - 1;\n        const childConfig: QuadTreeConfig = Object.assign({}, this.config, {maximumDepth: childMaximumDepth});\n\n        this.isDivided = true;\n\n        const x = this.container.x;\n        const y = this.container.y;\n        const w = this.container.w / 2;\n        const h = this.container.h / 2;\n\n        // Creation of the sub-nodes, and insertion of the current point\n        this.ne = new QuadTree(new Box(x + w, y, w, h), childConfig);\n        this.nw = new QuadTree(new Box(x, y, w, h), childConfig);\n        this.se = new QuadTree(new Box(x + w, y + h, w, h), childConfig);\n        this.sw = new QuadTree(new Box(x, y + h, w, h), childConfig);\n\n        this.insert(this.points.slice());\n\n        // We empty this node points\n        this.points.length = 0;\n        this.points = [];\n    }\n\n    /**\n     * Remove a point in the QuadTree\n     * @param {(Point|Object|Point[]|Object[])} pointOrArray - A point or an array of points to remove\n     * @param {number} pointOrArray.x - X coordinate of the point\n     * @param {number} pointOrArray.y - Y coordinate of the point\n     */\n    remove(pointOrArray: Point | Point[]): void {\n        if (Array.isArray(pointOrArray)) {\n            for (const point of pointOrArray) {\n                this.removeRecursive(point);\n            }\n        } else {\n            this.removeRecursive(pointOrArray);\n        }\n    }\n\n    /**\n     * Remove a point in the QuadTree\n     * @param {(Point|Object)} point - A point to remove\n     * @param {number} point.x - X coordinate of the point\n     * @param {number} point.y - Y coordinate of the point\n     * @private\n     */\n    private removeRecursive(point: Point): void {\n        if (!this.container.contains(point)) {\n            return;\n        }\n\n        if (!this.isDivided) {\n            const len = this.points.length;\n            for (let i = len - 1; i >= 0; i--) {\n                if (this.config.arePointsEqual(point, this.points[i])) {\n                    this.points.splice(i, 1);\n                }\n            }\n\n            return;\n        }\n\n        this.ne.removeRecursive(point);\n        this.nw.removeRecursive(point);\n        this.se.removeRecursive(point);\n        this.sw.removeRecursive(point);\n\n        if (this.config.removeEmptyNodes) {\n            if (this.ne.getNodePointAmount() === 0 && !this.ne.isDivided &&\n                this.nw.getNodePointAmount() === 0 && !this.nw.isDivided &&\n                this.se.getNodePointAmount() === 0 && !this.se.isDivided &&\n                this.sw.getNodePointAmount() === 0 && !this.sw.isDivided) {\n\n                this.isDivided = false;\n\n                delete this.ne;\n                delete this.nw;\n                delete this.se;\n                delete this.sw;\n            }\n        }\n    }\n\n    /**\n     * Insert a point in the QuadTree\n     * @param {(Point|Object|Point[]|Object[])} pointOrArray - A point or an array of points to insert\n     * @param {number} pointOrArray.x - X coordinate of the point\n     * @param {number} pointOrArray.y - Y coordinate of the point\n     * @returns {boolean} true if the point or all the point has been inserted, false otherwise\n     */\n    insert(pointOrArray: Point | Point[]): boolean {\n        if (Array.isArray(pointOrArray)) {\n            let returnValue = true;\n            for (const point of pointOrArray) {\n                returnValue = returnValue && this.insertRecursive(point);\n            }\n            return returnValue;\n        } else {\n            return this.insertRecursive(pointOrArray);\n        }\n    }\n\n    /**\n     * Insert a point in the QuadTree\n     * @param {(Point|Object)} point - A point to insert\n     * @param {number} point.x - X coordinate of the point\n     * @param {number} point.y - Y coordinate of the point\n     * @returns {boolean}\n     * @private\n     */\n    private insertRecursive(point: Point): boolean {\n        if (!this.container.contains(point)) {\n            return false;\n        }\n        if (!this.isDivided) {\n            if (this.getNodePointAmount() < this.config.capacity || this.config.maximumDepth === 0) {\n                this.points.push(point);\n                return true;\n            } else if (this.config.maximumDepth === -1 || this.config.maximumDepth > 0) {\n                this.divide();\n            }\n        }\n\n        if (this.isDivided) {\n            return this.ne.insertRecursive(point) \n                || this.nw.insertRecursive(point) \n                || this.se.insertRecursive(point) \n                || this.sw.insertRecursive(point);\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Query all the point within a range\n     * @param {Shape} range - The range to test\n     * @returns {(Point[]|Object[])} - The points within the range\n     */\n    query(range: Shape): Point[] {\n        const pointsFound: Point[] = [];\n        this.queryRecursive(range, pointsFound);\n        return pointsFound;\n    }\n\n    /**\n     * @param {Shape} range\n     * @param {(Point[]|Object[])} pointsFound\n     * @returns {(Point[]|Object[])}\n     * @private\n     */\n    private queryRecursive(range: Shape, pointsFound: Point[]): void {\n        if (range.intersects(this.container)) {\n            if (this.isDivided) {\n                this.ne.queryRecursive(range, pointsFound);\n                this.nw.queryRecursive(range, pointsFound);\n                this.se.queryRecursive(range, pointsFound);\n                this.sw.queryRecursive(range, pointsFound);\n            } else {\n                const p = this.points.filter((point) => range.contains(point));\n\n                Array.prototype.push.apply(pointsFound, p);\n            }\n        }\n    }\n\n    /**\n     * Clear the QuadTree\n     */\n    clear(): void {\n        this.points = [];\n        this.isDivided = false;\n\n        delete this.ne;\n        delete this.nw;\n        delete this.se;\n        delete this.sw;\n    }\n}\n\n\n"],"names":["Box","[object Object]","x","y","w","h","data","this","point","range","Circle","r","rPow2","point1","point2","Math","pow","euclideanDistancePow2","dX","max","min","dY","Point","defaultConfig","capacity","removeEmptyNodes","maximumDepth","arePointsEqual","QuadTree","container","config","points","Object","assign","isDivided","insertRecursive","tree","ne","getTree","nw","se","sw","getNodePointAmount","pointsList","getAllPointsRecursive","Array","prototype","push","apply","slice","length","childMaximumDepth","childConfig","insert","pointOrArray","isArray","removeRecursive","contains","i","splice","returnValue","divide","pointsFound","queryRecursive","intersects","p","filter"],"mappings":"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"}